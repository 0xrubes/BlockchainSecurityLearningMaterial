pragma solidity ^0.8.7;

interface MeaningOfLifeContract {
    function whatIsTheMeaningOfLife() external  returns (uint16);
    function nonExistingFunction() external  returns (uint16);
}
//I was super confused why there was no need for the method identifier in the byte code, especially since the function signature was specifically mentioned in the level.
//So I ran this test of two 10byte contracts (one with a different value for fun) and tried them with a non-existing function signature.
//Still not sure exactly why this works in this way - I guess we defined the fallback function by not saving any function identifier along the way?


//web3.eth.sendTransaction({
//  from: player.address,
//  data: "0x600a600c600039600a6000f3602a60805260206080f3"
//});
//then set solver to created contract's address, win
contract Test {

    uint public resultCorrectContract ; // Should be 42
    uint public resultErrorContract; //Should be 66
    uint public difFunctionResultCorrectContract; // Is also 42! So the reason we do not need any function specifier is that any method call invokes our bytecode method
    uint public difFunctionResultErrorContract; //Also 66
    
    address correctContract = address(0xbA5E660496E3060790124864565cAad0D1550A68);
    address errorContract = address(0x650A6d3E82253232f7e8eB638FBD4746a086d554);


    function execute() public {

        resultCorrectContract = MeaningOfLifeContract(correctContract).whatIsTheMeaningOfLife();
        resultErrorContract = MeaningOfLifeContract(errorContract).whatIsTheMeaningOfLife();
        difFunctionResultCorrectContract = MeaningOfLifeContract(correctContract).nonExistingFunction();
        difFunctionResultErrorContract = MeaningOfLifeContract(errorContract).nonExistingFunction();
    }

  
}