// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//Minimal interfaces
interface DoubleEntryPoint{
    function cryptoVault() external returns(address);
    function forta() external returns(Forta);
}

interface Forta{
    function raiseAlert(address user) external;
}

contract MyDetectionBot {
    DoubleEntryPoint doubleEntryPoint;
    Forta forta;
    address cryptoVaultAddress;
    
    constructor(address _doubleEntryPointAddress){
        doubleEntryPoint = DoubleEntryPoint(_doubleEntryPointAddress);
        forta = doubleEntryPoint.forta();
        cryptoVaultAddress = doubleEntryPoint.cryptoVault();
    }
    
    function handleTransaction(address user, bytes calldata msgData) external{        
        //I really wonder why this doesn't work:

        //to = address(bytes20(bytes32(msgData[104:136])));
        //value = uint256(bytes32(msgData[136:168]));
        //origSender = address(bytes20(bytes32(msgData[168:200]))); 
        
        address origSender;
        assembly {
            //Due to ABI encoding, great help: https://github.com/maAPPsDEV/double-entry-point-attack/blob/main/contracts/DetectionBot.sol
            //and also https://docs.soliditylang.org/en/v0.8.15/abi-spec.html#examples
            origSender := calldataload(0xa8) 
        }

        //Honestly, I'm not really happy with this solution, as we effectively completely disable the sweepToken functionality and make the Vault unusable
        //In a scenario, where the vault would handle many more tokens, this would be a pretty bad solution
        //A better solution would be to detect that someone attempts specifically to sweep the LegacyToken and therefore the DET.
        // However, there is just _no way_ to determine which Token is being swept from the given calldata. We only know about the Vault, from which the sweep obviously originates,
        // the recipient and the value, we dont know anything about the token. A bit frustrating having such a solution for the final level, but I'm not going to let it ruin my mood :^)
        
        if(address(origSender) == cryptoVaultAddress){
            forta.raiseAlert(user);
        }
    }
}